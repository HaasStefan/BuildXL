// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;
using System.Diagnostics.ContractsLight;
using System.Diagnostics.Tracing;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using BuildXL.Utilities;
using BuildXL.Utilities.Core;
using BuildXL.Utilities.Serialization;

namespace BuildXL.Cache.Interfaces
{
    /// <summary>
    /// Handles registration of cache context activity guids
    /// </summary>
    public static class CacheActivityRegistry
    {
        private static AsyncLocal<Guid?> ActivityId;

        /// <summary>
        /// The byte index in cache activity ids used to indicate that the id is rooted
        /// and that the first 8 bytes should be preserved.
        /// </summary>
        public const int MarkerBitByteIndex = 8;

        /// <summary>
        /// The bit value in cache activity ids used to indicate that the id is rooted
        /// and that the first 6 bytes should be preserved.
        /// </summary>
        public const byte MarkerBitValue = 0x80;

        /// <summary>
        /// Sets the current context activity id
        /// </summary>
        public static void SetContextActivityId(Guid? activityId)
        {
            if (ActivityId == null)
            {
                Interlocked.CompareExchange(ref ActivityId, new(), comparand: null);
            }

            ActivityId.Value = activityId;
        }

        /// <summary>
        /// Gets the current context activity id
        /// </summary>
        public static Guid? GetContextActivityId()
        {
            return ActivityId?.Value;
        }

        /// <summary>
        /// Gets context activity id or new activity id if <paramref name="overrideActivityId"/> is not set.
        /// </summary>>
        public static Guid GetOrNewContextActivityId(Guid overrideActivityId)
        {
            if (overrideActivityId != default)
            {
                return overrideActivityId;
            }

            if (GetContextActivityId() is Guid activityId && activityId != default)
            {
                return activityId;
            }

            return Guid.NewGuid();
        }

        /// <summary>
        /// Gets whether activity id is rooted (<see cref="CreateNewId(Guid)"/>)
        /// </summary>
        public static bool IsRooted(Guid guid)
        {
            var bytes = MemoryMarshal.AsBytes(MemoryMarshalShim.CreateSpan(ref guid, 1));
            return (bytes[MarkerBitByteIndex] & MarkerBitValue) == MarkerBitValue;
        }

        /// <summary>
        /// Marks the activity id as rooted (<see cref="CreateNewId(Guid)"/>)
        /// </summary>
        public static void MarkRooted(ref Guid guid)
        {
            var bytes = MemoryMarshal.AsBytes(MemoryMarshalShim.CreateSpan(ref guid, 1));
            bytes[MarkerBitByteIndex] |= MarkerBitValue;
            Contract.Assert(IsRooted(guid));
        }

        /// <summary>
        /// <para>
        /// If the relatedId is marked with the 0x08 bit (at byte index = 8),
        /// it shall be treated as a "rooted" activity; in that case,
        /// its activity root (the first seven bytes) are copied to the new id.
        /// All activity ids generated by this class mark themselves as "rooted".
        /// </para>
        /// <para>
        /// Visual aid:
        ///                       80.. to signify rooted ID (byte index = 8)
        ///   {00000000-0000-0000-80XX-XXXXXXXXXXXX}
        ///    ^^^^^^^^-^^^^-^^^^-^^root bytes (length = 9)
        /// </para>
        /// </summary>
        public static Guid CreateNewId(Guid relatedId)
        {
            var newId = Guid.NewGuid();
            if (!IsRooted(relatedId))
            {
                MarkRooted(ref newId);
                return newId;
            }

            Span<byte> newIdSpan = MemoryMarshal.AsBytes(MemoryMarshalShim.CreateSpan(ref newId, 1));
            Span<byte> relatedIdSpan = MemoryMarshal.AsBytes(MemoryMarshalShim.CreateSpan(ref relatedId, 1));

            // Copy first 9 bytes
            relatedIdSpan.Slice(0, MarkerBitByteIndex + 1).CopyTo(newIdSpan);
            Contract.Assert(IsRooted(newId), $"'{newId}' should be rooted after copying bytes from '{relatedId}'");
            return newId;
        }

        /// <summary>
        /// Registers the activity id as the context activity for a given scope
        /// </summary>
        public static Registration Register(Guid activityId)
        {
            var registration = new Registration(GetContextActivityId());
            SetContextActivityId(activityId);
            return registration;
        }

        /// <summary>
        /// Disposable used to return to context activity to captured state.
        /// </summary>
        public struct Registration(Optional<Guid?> capturedContextActivityId) : IDisposable
        {
            /// <nodoc />
            public void Dispose()
            {
                if (capturedContextActivityId.HasValue)
                {
                    SetContextActivityId(capturedContextActivityId.Value);
            }
                }
        }
    }
}
